package ru.vavtech.ytestv4.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import ru.vavtech.ytestv4.model.Cash;
import ru.vavtech.ytestv4.model.Currency;

import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;

/**
 * Сервис для управления инвентарем денег в банкомате.
 * 
 * Обеспечивает thread-safety через использование:
 * - ConcurrentHashMap для безопасного доступа к данным в многопоточной среде
 * - ReentrantReadWriteLock для разделения операций чтения и записи
 * 
 * Поддерживает операции:
 * - Инициализация начального инвентаря банкомата
 * - Проверка количества купюр по номиналам
 * - Выдача купюр с контролем остатков
 * - Получение общих сумм по валютам
 * 
 * Thread-safety критически важна для банкомата, так как:
 * - Несколько пользователей могут одновременно снимать деньги
 * - Операции инкассации могут происходить параллельно с выдачей
 * - Мониторинг состояния банкомата должен получать актуальные данные
 */
@Slf4j
@Service
public class CashInventoryService {
    
    /**
     * Основное хранилище инвентаря банкомата.
     * Ключ: объект Cash (валюта + номинал)
     * Значение: количество купюр данного номинала
     * 
     * ConcurrentHashMap выбран для:
     * - Безопасности в многопоточной среде без блокировки всей коллекции
     * - Высокой производительности операций чтения (get, containsKey)
     * - Атомарности базовых операций (put, compute)
     */
    private final Map<Cash, Integer> inventory = new ConcurrentHashMap<>();
    
    /**
     * Блокировка для разделения операций чтения и записи.
     * 
     * ReadWriteLock позволяет:
     * - Множественным читателям работать параллельно (getCount, getCurrentInventory)
     * - Эксклюзивный доступ для операций записи (dispenseCash, initializeInventory)
     * - Предотвращение race conditions при сложных операциях
     * 
     * Это критично для банкомата, где чтение инвентаря происходит часто,
     * а изменения - относительно редко.
     */
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    
    /**
     * Инициализация банкомата начальным набором купюр.
     * 
     * Метод вызывается при старте приложения через CommandLineRunner.
     * Устанавливает типичный набор номиналов для банкомата с достаточным количеством
     * для обслуживания клиентов в течение операционного дня.
     * 
     * Используется write lock, так как происходит массовое изменение инвентаря.
     * Блокировка обеспечивает атомарность всей операции инициализации.
     */
    public void initializeInventory() {
        // Получаем эксклюзивную блокировку для записи
        // Это блокирует все операции чтения и записи до завершения инициализации
        lock.writeLock().lock();
        try {
            // Инициализация рублевыми купюрами
            // Набор номиналов покрывает большинство запросов клиентов:
            // - 5000₽ (10 шт = 50,000₽) - для крупных сумм  
            inventory.put(new Cash(Currency.RUB, 5000), 10);
            // - 1000₽ (50 шт = 50,000₽) - самый популярный номинал
            inventory.put(new Cash(Currency.RUB, 1000), 50);
            // - 500₽ (100 шт = 50,000₽) - для выдачи нестандартных сумм
            inventory.put(new Cash(Currency.RUB, 500), 100);
            // - 100₽ (200 шт = 20,000₽) - для точной выдачи остатков
            inventory.put(new Cash(Currency.RUB, 100), 200);
            
            // Инициализация долларовыми купюрами
            // Меньшее количество из-за менее частого использования:
            // - $100 (20 шт = $2,000) - для крупных валютных операций
            inventory.put(new Cash(Currency.USD, 100), 20);
            // - $50 (30 шт = $1,500) - популярный номинал для снятия
            inventory.put(new Cash(Currency.USD, 50), 30);
            // - $20 (50 шт = $1,000) - для средних сумм
            inventory.put(new Cash(Currency.USD, 20), 50);
            // - $10 (100 шт = $1,000) - для точной выдачи сумм
            inventory.put(new Cash(Currency.USD, 10), 100);
            
            // Логируем успешную инициализацию для мониторинга
            log.info("Инвентарь банкомата инициализирован");
        } finally {
            // Обязательно освобождаем блокировку в finally блоке
            // Это гарантирует освобождение даже при исключениях
            lock.writeLock().unlock();
        }
    }
    
    /**
     * Получение текущего количества купюр определенного номинала.
     * 
     * Метод используется для:
     * - Проверки доступности купюр перед выдачей
     * - Алгоритма выбора оптимального набора купюр
     * - Мониторинга состояния банкомата
     * 
     * @param cash объект, представляющий номинал и валюту купюры
     * @return количество доступных купюр (0 если номинал отсутствует)
     */
    public int getCount(Cash cash) {
        // Используем read lock для безопасного чтения
        // Позволяет множественным потокам читать одновременно
        lock.readLock().lock();
        try {
            // getOrDefault возвращает 0 для несуществующих номиналов
            // Это безопаснее чем get(), который может вернуть null
            return inventory.getOrDefault(cash, 0);
        } finally {
            // Освобождаем read lock
            lock.readLock().unlock();
        }
    }
    
    /**
     * Проверка возможности выдачи указанного количества купюр.
     * 
     * Быстрая проверка без изменения состояния инвентаря.
     * Используется в алгоритме выдачи денег для предварительной валидации.
     * 
     * @param cash тип купюры для проверки
     * @param count требуемое количество купюр
     * @return true если в банкомате достаточно купюр данного номинала
     */
    public boolean canDispense(Cash cash, int count) {
        // Используем read lock так как только читаем данные
        lock.readLock().lock();
        try {
            // Делегируем вызов getCount() с той же блокировкой
            // Это эффективно так как ReentrantReadWriteLock поддерживает реентрантность
            return getCount(cash) >= count;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * Выдача купюр (уменьшение инвентаря).
     * 
     * Критически важная операция, которая должна быть атомарной:
     * - Проверка доступности купюр
     * - Уменьшение количества в инвентаре
     * - Логирование операции
     * 
     * Метод предназначен только для физической выдачи купюр.
     * Вся логика валидации должна быть выполнена до вызова этого метода.
     * 
     * @param cash тип купюры для выдачи
     * @param count количество купюр для выдачи
     * @return true если операция выполнена успешно, false если недостаточно купюр
     */
    public boolean dispenseCash(Cash cash, int count) {
        // Используем write lock для эксклюзивного доступа
        // Это блокирует все операции чтения и записи на время выдачи
        lock.writeLock().lock();
        try {
            // Получаем текущее количество купюр данного номинала
            // getOrDefault защищает от NullPointerException
            int currentCount = inventory.getOrDefault(cash, 0);
            
            // Проверяем достаточность купюр для выдачи
            if (currentCount >= count) {
                // Атомарно уменьшаем количество купюр в инвентаре
                inventory.put(cash, currentCount - count);
                
                // Логируем успешную выдачу для аудита и мониторинга
                // DEBUG уровень так как операция происходит часто
                log.debug("Выдано {} купюр номиналом {}", count, cash);
                return true;
            }
            
            // Логируем попытку выдачи при недостатке купюр
            // WARN уровень так как это может указывать на проблему
            log.warn("Попытка выдать {} купюр номиналом {}, доступно только {}", 
                    count, cash, currentCount);
            return false;
        } finally {
            // Обязательно освобождаем write lock
            lock.writeLock().unlock();
        }
    }

    /**
     * Получение списка доступных купюр для указанной валюты.
     *
     * Фильтрует общий инвентарь банкомата по критериям:
     * - Совпадение валюты
     * - Ненулевое количество купюр
     *
     * Возвращает только те номиналы, которые реально можно использовать
     * в алгоритме поиска комбинации.
     *
     * @param currency валюта для фильтрации номиналов
     * @return список доступных номиналов указанной валюты
     */
    public List<Cash> getAvailableCashByCurrency(Currency currency) {
        return getCurrentInventory().entrySet().stream()
                // Фильтр 1: только нужная валюта
                // Фильтр 2: только номиналы с ненулевым количеством
                .filter(entry -> entry.getKey().currency() == currency && entry.getValue() > 0)
                // Извлекаем только ключи (объекты Cash) из пар ключ-значение
                .map(Map.Entry::getKey)
                // Собираем в изменяемый список для последующей сортировки
                .collect(Collectors.toList());
    }
    
    /**
     * Получение копии текущего состояния инвентаря.
     * 
     * Возвращает неизменяемую копию для:
     * - Безопасности (предотвращения изменения извне)
     * - Консистентности (снимок состояния на момент вызова)
     * - Мониторинга и отчетности
     * 
     * Используется в алгоритме поиска оптимального набора купюр.
     * 
     * @return неизменяемая копия текущего инвентаря
     */
    public Map<Cash, Integer> getCurrentInventory() {
        // Read lock для безопасного чтения всего состояния
        lock.readLock().lock();
        try {
            // Map.copyOf() создает неизменяемую копию
            // Это гарантирует, что внешний код не сможет изменить инвентарь
            // и получает консистентный снимок на момент вызова
            return Map.copyOf(inventory);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    /**
     * Получение общей суммы денег в банкомате по указанной валюте.
     * 
     * Вычисляет общую стоимость всех купюр данной валюты:
     * сумма = номинал_1 * количество_1 + номинал_2 * количество_2 + ...
     * 
     * Используется для:
     * - Проверки достаточности средств перед выдачей
     * - Мониторинга ликвидности банкомата
     * - Отчетности о состоянии инвентаря
     * 
     * @param currency валюта для подсчета общей суммы
     * @return общая сумма денег указанной валюты в банкомате
     */
    public BigDecimal getTotalAmount(Currency currency) {
        // Read lock для безопасного чтения и вычисления
        lock.readLock().lock();
        try {
            return inventory.entrySet().stream()
                    // Фильтруем только купюры нужной валюты
                    .filter(entry -> entry.getKey().currency() == currency)
                    // Преобразуем каждую запись в стоимость: номинал * количество
                    .map(entry -> {
                        // Конвертируем Integer номинал в BigDecimal для точных вычислений
                        BigDecimal denomination = BigDecimal.valueOf(entry.getKey().denomination());
                        // Конвертируем количество купюр в BigDecimal
                        BigDecimal count = BigDecimal.valueOf(entry.getValue());
                        // Возвращаем стоимость данного номинала
                        return denomination.multiply(count);
                    })
                    // Суммируем все стоимости, начиная с 0
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
        } finally {
            lock.readLock().unlock();
        }
    }
} 